\documentclass[12pt]{amsart}

\usepackage{a4wide}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot{}
\cfoot{\today}
\rfoot{\thepage}

\usepackage{algorithm2e}
\usepackage{graphicx}
\usepackage[parfill]{parskip}
\usepackage{appendix}
\usepackage{amsmath}
\usepackage{multicol}

\renewcommand{\labelitemi}{-}
\renewcommand{\labelitemii}{-}
\renewcommand{\thefootnote}{\roman{footnote}}

\setcounter{secnumdepth}{10}
\setcounter{tocdepth}{3}

\title{Trader Game}
\author{Ethel Bardsley, Joseph Slade and Thomas Wood}

\begin{document}

\maketitle

\section{Introduction}
  % Brief rundown of the spec
\section{Concept}
  % Brief explanation of the game
\section{Frontend}
  % How this work
  \subsection{Renderer}
    \subsubsection{Choice of Technology}
      \begin{flushleft}
        There are a variety of technologies for browser-based rendering. The
        most obvious is Adobe Flash, as well Microsoft's Silverlight. However,
        while these are powerful tools with a wide selection of libraries and
        well-trodden paths for development, neither are universally cross
        platform, and Silverlight is not supported by the version of Firefox
        on the test machines.

        For handling the rendering with just HTML and Javascript, one method is
        to render by manipulating the DOM\footnote{Document Object Model}, and
        there are a few libraries for writing renderers using this method.
        However, DOM manipulation can suffer performance issues, particularly
        where there are many elements being drawn.

        Canvas is a relatively new technology, introduced with HTML5. It allows
        for procedurally drawing directly to an image with Javascript, and is
        supported by Gecko, WebKit (including mobile versions) and, from version
        9, Internet Explorer. There aren't many libraries available for it, and
        those that are aren't mature or well documented. However, canvas itself
        has sufficient framework for 2D sprite drawing, and I took this as a
        chance to learn through my own experience how a 2D renderer can be made.
      \end{flushleft}

    % Combined actor/data, progression from separate to needing them combined
    % Render loop
    % Various efficiency hacks
    % Alternate ideas
    \subsubsection{Implementation}
      \begin{flushleft}
        The render initializes by setting up the canvas element and render
        context, loading map data from the server, using that to generate a
        background image and place any scenery sprites (eg, shops). It then
        centers the view, adds an input handler, before starting the render
        loop.

        The field in the background is procedurally generated, being a
        different image each time the page is loaded. Pixels are a random
        color, weighted toward being a light green. Originally, I tried to have
        each pixel in the map generated uniquely, but this was very CPU
        intensive, causing the page to hang, or even crash. To remedy this,
        instead it generates a set of temporary smaller canvas tiles and uses
        those to build the larger background, which is considerably more
        performant.

        Sprite animation currently supports 2 actions, \verb/stand/ and
        \verb/walk/, although is easily extensible to take more as needed. Each
        action has a number of sprites associated with it, which are simply
        stepped through, 1 per redraw, moving the sprite across the screen if
        necessary. Because of it's simplicity, however, attacking motions must
        happen independently in their own render queue to prevent the main
        actor sprite from disappearing.
      \end{flushleft}
  \subsection{Network}
    \begin{flushleft}
      The frontend makes extensive use of the XMLHttpRequest interface provided 
      by the browser. This interface permits additional HTTP requests to be made 
      to the server by the client-side JavaScript to request that an action be 
      recorded in the database, or to receive more data.

      The client to server data encoding is the same as a standard HTML form 
      would be transmitted as, namely the 
      \verb|application/x-www-form-urlencoded| MIME-type. This is reasonably 
      simple to construct with JavaScript, with each field name and value
      string being URL-escaped then concatenated into a string with \verb|=| 
      separating the fields from the values, and \verb|&| being used to separate 
      each individual field.\footnote{See also: W3C HTML 4.01 Specification Section 
      17.13.4} This format is advantageous for receipt on the server-side as PHP 
      automatically parses requests made in this format and makes them available
      to the program.

      The server to client data is encoded using JSON\footnote{JavaScript Object 
      Notation}. This format is advantageous as a transfer format as it 
      concicely encodes complex data-structures into a reasonably human-readable 
      string. Both PHP and JavaScript provide built-in functions to encode and 
      parse this format, respectively.

      We have also implemented a server-push notifications system using the 
      long-polling of multipart HTTP requests. HTTP is generally limited by the 
      fact that requests can only be made in one direction - a client can only 
      request data from a server, the server cannot arbitrarily open a 
      connection to the client to notify it of an event.
      
      Long-polling is one 
      method to overcome this limitation. Long-polling is when a client makes a 
      request to the server to send it data but if the server has no data to 
      send at the time the request is made, the server holds the connection open 
      until it is ready to send some.
      
      Multipart requests permit multiple distinct responses from the server to 
      the client for an individual request. In standard practice, the content of 
      any previous responses is replaced by the content a new incoming response.

      The combination of long-polling with multipart reponses permits 
      server-pushing to be achieved. As an added precaution against underlying 
      connection timeouts, each long-poll request is terminated after 60 seconds 
      and re-initiated.
    \end{flushleft}
\section{Backend}
  \subsection{Choice of Technology}
    \begin{flushleft}
      Our choice of server-side technology was decided by a combination of the
      skills the members of the group already had and for the ease of use with
      the department's Apache server. We chose PHP as the backend programming
      language for several reasons, firstly there was a minimal setup time
      required to get code to work with the provided server, secondly the
      language transparently handles many of the complexities of handling
      requests, thirdly PHP is very similar in syntax to C and in OO-style to
      Java, both languages that the group are familiar with, and finally PHP is
      bundled with a large number of interfaces to external libraries.  In
      particular we use the PDO\footnote{PHP Data Objects} class to interface
      with the PostgresSQL database and the SystemV Semaphore library for
      low-overhead message passing between processes.
    \end{flushleft}

  \subsection{Implementation}
    \begin{flushleft}
      Our code structure aims to meet the MVC\footnote{Model View Controller} 
      pattern of object-oriented programming, for this we opted to use one third 
      party PHP library, the ToroPHP Framework\footnote{http://www.toroweb.org/, 
      the code is assumed to be freely licenced as all documentation implies so} 
      is a small (150 line) class to route requests to appropriate handler 
      (controller) classes.

      We implemented a basic object-relational mapping class to make database 
      requests as straightforward as possible. This provides a class for each 
      data model, with appropriate actions for those models.
    \end{flushleft}

\section{Conclusion}
  % Wrap up, reiterate all the above in short
  \begin{flushleft}
    While we did not acomplish everything we set out to do, we were for the
    most part successful, and with extra time could have accomplished more. 
  \end{flushleft}

\end{document}

