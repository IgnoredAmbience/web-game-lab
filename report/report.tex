\documentclass[12pt]{amsart}

\usepackage{a4wide}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{}
\lfoot{}
\cfoot{\today}
\rfoot{\thepage}

\usepackage{algorithm2e}
\usepackage{graphicx}
\usepackage[parfill]{parskip}
\usepackage{appendix}
\usepackage{amsmath}
\usepackage{multicol}

\renewcommand{\labelitemi}{-}
\renewcommand{\labelitemii}{-}
\renewcommand{\thefootnote}{\roman{footnote}}

\setcounter{secnumdepth}{10}
\setcounter{tocdepth}{3}

\title{Trader Game}
\author{Ethel Bardsley, Joseph Slade and Thomas Wood}

\begin{document}

\maketitle

\section{Introduction}
  % Brief rundown of the spec
\section{Concept}
  % Brief explanation of the game
\section{Frontend}
  % How this work
  \subsection{Renderer}
    \subsubsection{Choice of Technology}
      \begin{flushleft}
        There are a variety of technologies for browser-based rendering. The
        most obvious is Adobe Flash, as well Microsoft's Silverlight. However,
        while these are powerful tools with a wide selection of libraries and
        well-trodden paths for development, neither are universally cross
        platform, and Silverlight is not supported by the version of Firefox
        on the test machines.

        For handling the rendering with just HTML and Javascript, one method is
        to render by manipulating the DOM\footnote{Document Object Model}, and
        there are a few libraries for writing renderers using this method.
        However, DOM manipulation can suffer performance issues, particularly
        where there are many elements being drawn.

        Canvas is a relatively new technology, introduced with HTML5. It allows
        for procedurally drawing directly to an image with Javascript, and is
        supported by Gecko, WebKit (including mobile versions) and, from version
        9, Internet Explorer. There aren't many libraries available for it, and
        those that are aren't mature or well documented. However, canvas itself
        has sufficient framework for 2D sprite drawing, and I took this as a
        chance to learn through my own experience how a 2D renderer can be made.
      \end{flushleft}

    % Combined actor/data, progression from separate to needing them combined
    % Render loop
    % Various efficiency hacks
    % Alternate ideas
    \subsubsection{Implementation}
      \begin{flushleft}
        The render initializes by setting up the canvas element and render
        context, loading map data from the server, using that to generate a
        background image and place any scenery sprites (eg, shops). It then
        centers the view, adds an input handler, before starting the render
        loop.

        The field in the background is procedurally generated, being a
        different image each time the page is loaded. Pixels are a random
        color, weighted toward being a light green. Originally, I tried to have
        each pixel in the map generated uniquely, but this was very CPU
        intensive, causing the page to hang, or even crash. To remedy this,
        instead it generates a set of temporary smaller canvas tiles and uses
        those to build the larger background, which is considerably more
        performant.

        Sprite animation currently supports 2 actions, \verb/stand/ and
        \verb/walk/, although is easily extensible to take more as needed. Each
        action has a number of sprites associated with it, which are simply
        stepped through, 1 per redraw, moving the sprite across the screen if
        necessary.
      \end{flushleft}
  \subsection{Netcode}
    \begin{flushleft}
    \end{flushleft}
\section{Backend}
  \subsection{Choice of Technology}
    \begin{flushleft}
      Our choice of server-side technology was decided by a combination of the skills the members of the group already had and for the ease of use with the department's Apache server. We chose PHP as the backend programming language for several reasons, firstly there was a minimal setup time required to get code to work with the provided server, secondly the language transparently handles many of the complexities of handling requests, thirdly PHP is very similar in syntax to C and in OO-style to Java, both languages that the group are familiar with, and finally PHP is bundled with a large number of interfaces to external libraries.
In particular we use the PDO\footnote{PHP Data Objects} class to interface with the PostgresSQL database and the SystemV Semaphore library for low-overhead message passing between processes.

We opted to use one third party PHP library, the ToroPHP Framework\footnote{http://www.toroweb.org/, the code is assumed to be freely licenced as all documentation implies so} is a small (150 line) class to route requests to appropriate handler classes.
    \end{flushleft}

  \subsubsection{Design}
    \begin{flushleft}
      All requests to the backend are routed to the \verb|index.php| script by the webserver's configuration in \verb|.htaccess|.
      This script parses the request path and then dispatches it to the correct Handler class.
    \end{flushleft}
\section{Conclusion}
  % Wrap up, reiterate all the above in short

\end{document}

